---
title: React Virtual Dom
date: '2022-08-04'
tags: ['react', 'front', 'hook']
draft: false
comment: React Virtual Dom
---

```jsx
const state = {
  _data: 'hello world ',
};
const render = () => (document.body.innerHTML = `<div>${state.data}</div>`);

Object.defineProperty(state, 'data', {
  get() {
    console.log('get');
    return state._data;
  },
  set(value) {
    console.log('set');
    state._data = value;
    render();
  },
});

render();

state.data = '안녕';
state.data = 'hello world';
```

함수 시그니처에 따라 대상 객체인 state와 정의할 속성 이름 "data"를 문자열로 전달했다. 그리고 descriptor 객체를 설정할 수 있는데 속성에 접근하는 게터(get())와 세터(set()) 함수를 정의할 수 있다(3).

게터에서는 \_data의 값을 그대로 반환(1)하고 세터에서는 인자로 들어온 값을 \_data 에 할당했다(2). 이제 data 속성에 접근할 때 다른 로직을 추가할 수 있는 기회가 생겼다. 위 코드에서는 로그만 기록하도록 했다. state.data로 접근하거나 값을 할당하면 각 로그가 찍힐 것이다.

state.data에 값을 할당하면 UI를 업데이트 작업을 추가한다. render() 함수를 빼둔 것이 바로 이 때문이다. data 값을 변경하고 나면 곧장 render() 함수를 실행해(3) UI를 업데이트할 것이다. 데이터 변경이 자동으로 UI까지 영향을 미치는 것이다.

데이터와 앨리먼트를 동시에 변경하면서 화면을 제어했다. 이번 편에서는 데이터만 제어하면 자동으로 화면까지 반응한다. 이렇게 특정 값에 의존해 자동으로 반응하는 것을 **리액티브(reactive) 하다**라고 표현한다.

리액트를 비롯한 모던 UI 라이브러리는 이러한 리액티브한 특징을 가지고 있다. MVC 모델에서는 컨트롤러가 데이터와 뷰를 직접 관리한다. 어플리케이션을 동작시킬 때 모델도 변경하고 뷰도 빠짐없이 챙겨야하는 것이다.

한편 UI 상태를 나타내는 것을 뷰모델(View Model, 줄여서 VM)이라고 하는데 컨트롤러의 역할을 뷰모델이 일부 대체한다. 뷰모델을 변경하는 것만으로 UI를 자동으로 갱신하기 때문이다. 어플리케이션의 움직이는 모습을 기술하는 것 보다 상태만 기술하는 방식이 더 선언적이고 읽기 쉬운 코드를 만들 수 있다.

# 가상돔

데이터만 관리하면 값의 변화가 UI까지 반영되다는 것은 무척 매력적인 아이디어다. 코드양이 줄어드니깐. 그만큼 버그도 줄어 든다. 한편 상태 변화가 UI에 반영되려면 DOM API 호출은 불가피하다. 상태가 변하는 횟수만큼 돔 API 호출은 비례한다. 이것은 곧장 브라우져 성능에 영향을 주는 요인이 된다.

브라우져가 HTML과 CSS로 화면을 그리는 과정은 다음과 같다.

1. HTML 코드를 파싱해서 DOM 트리를 만든다
2. CSS 코드를 CSSOM 트리를 만든다
3. 두 트리를 합쳐 렌더트리를 만든다
4. 레이아웃을 계산한다
5. 픽셀로 화면에 그린다

주요렌더링경로(Critical Render Path)라고도 불리는 이 과정은 자바스크립트로 돔 구조를 변경하면 레이아웃다시 계산에 픽셀로 화면에 다시 그린다. 돔을 수정한만큼 이 작업이 반복되기 때문에 페이지 렌더링 성능에 영향을 주는 요소이다.

캐쉬. 디스크에 담겨있는 프로그램 명령어는 CPU까지 가야만 실행된다. 디스크에 접근하는 시간은 비교적 무척 느리기 때문에 이를 개선하기 위해 중간에 메모리를 캐쉬로 두어 명령어 로딩 속도를 올리는 것이다. 돔 호출도 이런식으로 캐쉬 계층을 두면 해결할 수 있지 않을까?

트리 구조의 돔과 유사한 **가상돔(Vritual DOM)**을 만들어 메모리에서 관리할 수 있겠다. 어플리케이션에서 화면 변경을 돔에게 직접 요청하는 것이 아니라 가상돔에게 요청한다. 리액트는 렌더링할 때마다 전체 가상돔을 만들고 이전 가상돔과의 차이를 찾는다. 차이가 있는 부분만 실제 돔에 반영하고 차이가 없으면 렌더링 요청이 있더라도 무시하는 방식으로 성능을 낸다.

- 참고: [https://www.youtube.com/watch?v=BYbgopx44vo](https://www.youtube.com/watch?v=BYbgopx44vo)

가상돔은 특정 기술이라기 보다는 패턴이라고 말할 수 있다. 즉 구현하는 방식에 따라 동작하는 것이 조금씩 다를수 있는데 리액트에서는 보통 UI를 말하는 개념이다. 이후에 나올 리액트 앨리먼트(React Element)와 관련되는데 그 때 API를 보면서 살펴보자.
